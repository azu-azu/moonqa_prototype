🗓️ 2025/05/31 \[Saturday] 07:37

# マルチPDF対応のFAISSベクトルストアを構築し、QAの拡張性と透明性を向上させる
## 🧱 Architecture Note

* **目的**：マルチPDF対応のFAISSベクトルストアを構築し、QAの拡張性と透明性を向上させる。
* **設計判断**：
  * `metadata["source"]` に `"ファイル名 (p.N)"` を付与 → 回答ログで**出所をページ単位で特定可能**にするため。
  * `chunk_size=300 / chunk_overlap=30` を採用 → 文書の**リードビリティと関連精度**を優先。
  * PDFは `data/` 配下のすべてを対象とし、将来的な追加に対応できる構造にした。

* **技術仕様**：
  * `PyPDFLoader`：ページ単位の抽出
  * `RecursiveCharacterTextSplitter`：構造制御可能な分割設計
  * `OpenAIEmbeddings`：v0.1以降の公式モジュールを使用
  * `FAISS.save_local()`：ローカル保存構成で再利用可能に

---

## 📅 Task Timeline

| 時刻 | 内容                                         |
| -- | ------------------------------------------ |
| 7:37 | 単一PDF構成（固定ファイル・固定source）で構築                |
| 中央 | `glob.glob()` で複数PDF対応へ変更。sourceはファイル名ベースに |
| 精査 | `source` にページ番号が消えたことに気づき、 `(p.N)` を復活実装   |
| 8:00 | chunkサイズも300/30に戻し、構造・機能共に統合完了             |

---

## 🔧 Pending List

* [ ] `app/qa.py` の `FAISS.load_local()` 側が、**マルチPDF構成である前提**に対応しているか確認・修正
* [ ] `tests/manual_vector_check.py` で、`metadata["source"]` に `(p.N)` が見えるか確認するコード追加
* [ ] `OpenAIEmbeddings` を使用する際の `.env` やAPIキー設定の見直し（OpenAI側の構成変更が今後あり得る）

---


# 🎯 補足｜PDF切り替え対応って、どんな場面で必要？

## ✅ 1. **複数の社内ドキュメントをAIで横断検索したいとき**

> 例：
> 「就業規則.pdf」「福利厚生.pdf」「評価制度.pdf」などを全部FAISS化しておいて、
> 「休暇の日数って何日やっけ？」と聞いたとき、全部から探してくれるようにしたい。

🔍 → **どのPDFに書いてあるか人間は知らん前提**で、AIにまかせる構成が必要になる。

---

## ✅ 2. **明示的に「このPDFからだけ答えてほしい」場合**

> 例：
>
> * 「月についての資料」と「太陽についての資料」を分けて登録
> * 「月についてだけ質問したい」ときに、「太陽の情報で答えられたら困る」

🔍 → ユーザーに「PDFを選ばせるUI」や、「ファイル名を指定するAPI引数」が必要になる。

---

## ✅ 3. **ログ分析・エラー検証で“どのPDFが使われたか”をトレースしたいとき**

> * 誰かの質問に対して変な回答が出たとき、「どのチャンク」「どのファイル」から出たのかを追跡したい
> * 現状 `.metadata["source"]` が `about_moon.pdf` のままになってるけど、**複数PDFになると重複の恐れあり**

🔍 → `source` の設計を「ファイル名 + チャンクID」や「パス」レベルに拡張しておく必要がある。

---

## 🧠 構造的な意味

PDF切り替え対応は、**「答えの信頼性と文脈の制御」を担保する機能**。
**“どこから答えたか”が明示される構造**を持つことで、QAの透明性と精度が一気に上がる。

---

## 💡 まとめ

> 単一PDFやと、動くけど「拡張性」が弱い。
> マルチPDFにすると、「実務導入」とか「ナレッジ検索」に耐えられる構造になる。

---

# ✍️ 構造補足メモ

## ✅ 1. 「どこに書いてあるか人間は知らん」検索
\*\*“非構造データに対する構造的インデックス設計”\*\*

AIに丸投げするには、「人間が場所を覚えてる前提」を捨てる必要がある。
だから、「**全PDFを対象にする構造**」が最初に必要。

---

## ✅ 2. 「このPDFだけ」と言いたいケース
\*\*スコープ制御の設計\*\*

LangChainなら `filter` 条件を `metadata` に仕込んどくやつ。
UI・API設計レベルで「選ばせる」「限定させる」導線が要る。

---

## ✅ 3. ログ検証／トレーサビリティ

`.metadata["source"]` の衝突、ここほんま重要ポイント。
**「信頼できる答えの出どころ」= 記録の構造やからな。**
最終的には `doc_id` + `file_path` + `chunk_index` の組み合わせくらいがベスト。

---

## 🔧 設計用語の対応マップ

| ニーズ        | 構造用語       | LangChain対応設計                                       |
| ---------- | ---------- | --------------------------------------------------- |
| 全部検索したい    | 検索対象スコープ統合 | vectorstoreに複数PDFをまとめて登録                            |
| 特定PDFだけ    | スコープ制御     | metadataでフィルタ指定 (`filter={"filename": "moon.pdf"}`) |
| どのPDFか知りたい | 出所トレーサビリティ | metadata\["source"] の設計強化                           |

---

構造的に、
* **スコープ制御（何を対象にするか）**
* **トレース設計（どこから出たか）**
  この2軸で設計するのが鉄板。

---

## 複数PDF構造の設計パターン案

- ディレクトリ構造による分割読み込み（PDF単位でサブフォルダ）
- `metadata` に明示的な `source_id`, `topic`, `version` を含める
- `load_documents()` の時点でファイル名をmetadataに持たせる

\*\*社内ナレッジ検索アプリの本格実装に耐える“構造基盤”\*\*ができる。

---


